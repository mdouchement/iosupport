package iosupport

import (
	"bufio"
	"io"
	"os"
)

// This Scanner provides very large file reader (also file with very long lines).
// Main usages:
//
// sc := supports.NewScanner(file)
// for sc.ScanLine() {
//   println(sc.Text())
//   println(sc.Bytes())
// }
//
// sc := supports.NewScanner(file)
// sc.EachString(func(line string, err error) {
//   println(line)
// })
//
// sc := supports.NewScanner(file)
// sc.EachLine(func(line []byte, err error) {
//   println(line)
// })
//
// See other methods for custom usage

var (
	// LF -> linefeed
	LF byte = '\n'
	// CR -> carriage return
	CR       byte = '\r'
	newLines      = []byte{CR, LF}
)

// Scanner conatins all stuff for reading a buffered file
type Scanner struct {
	f       *os.File      // The file provided by the client.
	r       *bufio.Reader // Buffered reader on given file.
	keepnls bool          // Keep the newline sequence in returned strings
	token   []byte        // Last token returned by split (scan).
	err     error         // Sticky error.
	seekers []seeker      // Internal use
}

// Internal use
type seeker struct {
	f      *os.File
	offset int64
}

// NewScanner instanciates a Scanner
func NewScanner(f *os.File) *Scanner {
	return &Scanner{
		f:       f,
		r:       bufio.NewReader(f),
		keepnls: false,
		seekers: []seeker{seeker{f, 0}},
	}
}

// KeepNewlineSequence keeps the newline sequence in read lines
func (s *Scanner) KeepNewlineSequence(b bool) {
	s.keepnls = b
}

// Bytes returns the most recent line generated by a call to Scan.
// The underlying array may point to data that will be overwritten
// by a subsequent call to Scan. It does no allocation.
func (s *Scanner) Bytes() []byte {
	return s.token
}

// Text returns the most recent line generated by a call to Scan
// as a newly allocated string holding its bytes.
func (s *Scanner) Text() string {
	return string(s.token)
}

// Err returns the first non-EOF error that was encountered by the Scanner.
func (s *Scanner) Err() error {
	if s.err == nil || s.err == io.EOF {
		return nil
	}
	return s.err
}

// ScanLine advances the Scanner to the next line), which will then be
// available through the Bytes or Text method. It returns false when the
// scan stops, either by reaching the end of the input or an error.
// After Scan returns false, the Err method will return any error that
// occurred during scanning, except that if it was io.EOF, Err
// will return nil.
func (s *Scanner) ScanLine() bool {
	// Override token value to new bytes array
	s.token = make([]byte, 0)

	// Loop until we have a token.
	for {
		b, err := s.r.ReadByte()

		// End-of-file detection or error detection
		if err != nil {
			s.err = err
			return !s.IsLineEmpty()
		}

		switch b {
		case LF:
			s.handleNewLineSequence(LF, CR)
			return true
		case CR:
			s.handleNewLineSequence(CR, LF)
			return true
		default:
			s.token = append(s.token, b)
		}
	}
}

// EachLine iterate on each line and execute the given function
func (s *Scanner) EachLine(fn func([]byte, error)) {
	s.Reset()
	for s.ScanLine() {
		fn(s.Bytes(), s.Err())
	}
}

// EachString iterates on each line as string format and execute the given function
func (s *Scanner) EachString(fn func(string, error)) {
	s.Reset()
	for s.ScanLine() {
		fn(s.Text(), s.Err())
	}
}

// Records the first error encountered.
func (s *Scanner) setErr(err error) {
	if s.err == nil || s.err == io.EOF {
		s.err = err
	}
}

// IsLineEmpty says if the current line is empty (only when newline character is not keeped)
func (s *Scanner) IsLineEmpty() bool {
	return len(s.token) == 0
}

// Reset seek to top of file
func (s *Scanner) Reset() {
	s.f.Seek(0, 0)
}

func (s *Scanner) handleNewLineSequence(currentNl, nextNl byte) {
	if s.keepnls {
		// Keep current newline character (relative to the seek)
		s.token = append(s.token, currentNl)
	}

	for {
		b, err := s.r.Peek(1)
		if err != nil {
			s.err = err
			return
		}

		if b[0] == nextNl {
			if s.keepnls {
				// Keep next newline character (relative to the currentNl)
				s.token = append(s.token, nextNl)
			}
			s.r.ReadByte()
		} else {
			return
		}
	}
}

// -------------------------- //
// Random accessor stuff      //
// -------------------------- //

// appendSeeker appends a new seeker based on given offset. Seekers must be appened ordering by the offset
func (s *Scanner) appendSeeker(offset int64) {
	f, _ := os.Open(s.f.Name())
	s.seekers = append(s.seekers, seeker{f, offset})
}

// selectSeeker returns the rearest inferior seeker
// e.g. A file with 10,000,000 lines
//    s0 -> offset 0
//    s1 -> offset 2,500,000
//    s2 -> offset 5,000,000
//    s3 -> offset 7,500,000
// offset 666 returns seeker s0
// offset 9,999,999 returns seeker s3
func (s *Scanner) selectSeeker(offset int64) seeker {
	for i, seeker := range s.seekers {
		if seeker.offset > offset {
			return s.seekers[i-1]
		}
	}
	return s.seekers[len(s.seekers)-1]
}

var cpt = make(map[int64]int64)

func (s *Scanner) readAt(offset int64, limit int) ([]byte, error) {
	token := make([]byte, limit)

	cpt[s.selectSeeker(offset).offset]++

	if _, err := s.selectSeeker(offset).f.ReadAt(token, offset); err != nil {
		return nil, err
	}
	return token, nil
}
