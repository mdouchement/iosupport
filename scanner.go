package iosupport

import (
	"bufio"
	"io"
	"os"
)

// This Scanner provides very large file reader (also file with very long lines).
// Main usages:
//
// sc := supports.NewScanner(file)
// for sc.ScanLine() {
//   println(sc.Text())
//   println(sc.Bytes())
// }
//
// sc := supports.NewScanner(file)
// sc.EachString(func(line string, err error) {
//   println(line)
// })
//
// sc := supports.NewScanner(file)
// sc.EachLine(func(line []byte, err error) {
//   println(line)
// })
//
// See other methods for custom usage

var (
	LF byte = '\n'
	CR byte = '\r'
	newLines []byte = []byte{CR, LF}
)

type Scanner struct {
	f     *os.File      // The file provided by the client.
	r     *bufio.Reader // Buffered reader on given file.
	token []byte        // Last token returned by split (scan).
	err   error         // Sticky error.
}

func NewScanner(f *os.File) *Scanner {
	return &Scanner{
		f: f,
		r: bufio.NewReader(f),
	}
}

// Bytes returns the most recent line generated by a call to Scan.
// The underlying array may point to data that will be overwritten
// by a subsequent call to Scan. It does no allocation.
func (s *Scanner) Bytes() []byte {
	return s.token
}

// Text returns the most recent line generated by a call to Scan
// as a newly allocated string holding its bytes.
func (s *Scanner) Text() string {
	return string(s.token)
}

// Err returns the first non-EOF error that was encountered by the Scanner.
func (s *Scanner) Err() error {
	if s.err == nil || s.err == io.EOF {
		return nil
	}
	return s.err
}

// ScanLine advances the Scanner to the next line), which will then be
// available through the Bytes or Text method. It returns false when the
// scan stops, either by reaching the end of the input or an error.
// After Scan returns false, the Err method will return any error that
// occurred during scanning, except that if it was io.EOF, Err
// will return nil.
func (s *Scanner) ScanLine() bool {
	// Override token value to new bytes array
	s.token = make([]byte, 0)

	// Loop until we have a token.
	for {
		b, err := s.r.ReadByte()

		// End-of-file detection or error detection
		if err != nil {
			s.err = err
			return !s.IsLineEmpty()
		}

		switch b {
		case LF:
			s.clearNewLineSequence(CR)
			return true
		case CR:
			s.clearNewLineSequence(LF)
			return true
		default:
			s.token = append(s.token, b)
		}
	}
}

// EachLine iterate on each line and execute the given function
func (s *Scanner) EachLine(fn func([]byte, error)) {
	s.Reset()
	for s.ScanLine() {
		fn(s.Bytes(), s.Err())
	}
}

// EachLine iterate on each line as string format and execute the given function
func (s *Scanner) EachString(fn func(string, error)) {
	s.Reset()
	for s.ScanLine() {
		fn(s.Text(), s.Err())
	}
}

// Records the first error encountered.
func (s *Scanner) setErr(err error) {
	if s.err == nil || s.err == io.EOF {
		s.err = err
	}
}

func (s *Scanner) IsLineEmpty() bool {
	return len(s.token) == 0
}

// Reset seek to top of file
func (s *Scanner) Reset() {
	s.f.Seek(0, 0)
}

func (s *Scanner) clearNewLineSequence(nl byte) {
	for {
		b, err := s.r.Peek(1)
		if err != nil {
			s.err = err
			return
		}

		if b[0] == nl {
			s.r.ReadByte()
		} else {
			return
		}
	}
}
